## 1 Задание

##### Сколько ушло времени?

> 4 часа

Изначально хотел сделать при помощи _рекурсивной функции_, но она выдаст мне все значения нашего обьекта, в итоге спустя какое-то время до меня дошло, что можно попробовать что-то сделать с **path** , и спустя какое-то время у меня наконец получилось.

#### Решение задачи

```
const getObjectProperty = (obj, path, defaultValue) => {
  let ourPathSplit = path.split(".") // Разбиваем наш path на отдельные слова(св-ва) обьекта и кладется в массив
  let res = obj // Создаем переменную res  и присваиваем ей значения нашего обьекта с аргументов(obj)
  for (let i = 0; i < ourPathSplit.length; i++) {
    // Создаем цикл и пробегаемся по нашему массиву путей
    if (ourPathSplit[i] in res) {
      // Проверяем есть ли ourPathSplit[i] (подстрока) в нашем обьекте ?
      res = res[ourPathSplit[i]] // В успешном случае результату будет присвоено значение нашего передаваемого пути ourPathSplit
    } else {
      res = defaultValue // В противном случае наш результат будет defaultValue из аргументов
      break
    }
  }
}
```

## 2 Задание

### Страница авторизации

Много думал как по красивому реализовать регистрацию без подключения сторонних менеджеров состояния и остановился на useContext, сделал Контекст для перехода на страницу с OTP, также форму валидации и проверку валидности введенных данных, если все ввели правильно нас перекидывает на страницу с одноразовым паролем, если нет, то вылазеет алерт и ругается на нас что мы ввели что-то неправильно

- _Правильный логин и пароль спрятал в **env** файл_
  > Потратил времени: **1 день**

### Страница с одноразовым паролем

Сделал функцию которая генерирует наш случайный ключ, при первом рендере компонента и проверку валидность введенных данных с инпута _Ключ вылазеет в алерте и в консоли_, если все правильно ввели, состояние _auth_ меняется и нас перекидывает на главную страницу нашего приложения, также во время этой страницы сделал хук useLocalStorage который запоминает и изменяет наше состояние auth в браузер и настроил защищенный роутинг в приложении, честно ушло много времени на типизацию Провайдеров, т.к мудрил очень и в итоге потратил на это целый день.

>

### Главная страница с нашими покемонами

> На ней мы отрисовываем наших покемонов с сервера и рендерим компонент Table, где находиться наша карточка
>
> > Также сделал легкую Пагинацию, и при нажатии в карточке на картинку, вылазеет модальное окно с большой картинкой этой карточки.
> > Чтобы посмотреть подробнее о покемоне, нужно кликнуть на его имя, после нас перебросит на страничку **PokemonPage** с данными о покемоне, где мы через id в url берем данные с сервера о каждом покемоне.

Проэкт делал примерно полторы недели, ошибки возникали с логикой декомпозиции приложения, т.к я изначально начал все разбивать на мелкие файлы(отдельные куски кода, логики) в итоге у меня ничего не работало, пришлось избавиться от столь тщательного оверинженеринга, потратил на это дня 4)))
